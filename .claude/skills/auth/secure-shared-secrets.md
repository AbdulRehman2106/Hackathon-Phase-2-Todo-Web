# Secure Handling of Shared Secrets

## Purpose
Guide the secure management of shared secrets (JWT secrets, API keys, database credentials) in application development and deployment.

## Skill Description
This skill provides best practices for storing, accessing, and managing secrets to prevent unauthorized access and security breaches.

## What Are Shared Secrets?

### Definition
Sensitive information that must be kept confidential and is shared between system components.

### Types of Secrets

**Authentication Secrets**:
- JWT signing keys
- Session secrets
- OAuth client secrets
- API keys

**Database Credentials**:
- Database passwords
- Connection strings
- Database encryption keys

**External Service Credentials**:
- Third-party API keys
- Service account credentials
- Webhook secrets

**Encryption Keys**:
- Data encryption keys
- File encryption keys
- Certificate private keys

## Security Principles

### 1. Never Hardcode Secrets

**Bad Practice**:
```python
# ❌ Never do this
JWT_SECRET = "my-secret-key-123"
DATABASE_URL = "postgresql://user:password@localhost/db"
API_KEY = "sk_live_abc123xyz"
```

**Why It's Bad**:
- Visible in source code
- Committed to version control
- Accessible to anyone with code access
- Difficult to rotate
- Different environments use same secrets

### 2. Use Environment Variables

**Good Practice**:
```python
# ✓ Correct approach
import os

JWT_SECRET = os.environ.get('JWT_SECRET')
DATABASE_URL = os.environ.get('DATABASE_URL')
API_KEY = os.environ.get('API_KEY')
```

**Benefits**:
- Secrets not in code
- Different per environment
- Easy to rotate
- Not committed to version control

### 3. Principle of Least Privilege

**Concept**: Grant minimum necessary access

**Application**:
- Database users with limited permissions
- API keys with specific scopes
- Service accounts with minimal roles
- Time-limited credentials when possible

### 4. Defense in Depth

**Multiple Layers**:
- Environment variables
- Encrypted storage
- Access controls
- Audit logging
- Regular rotation

## Environment Variables

### Local Development

**.env File**:
```bash
# .env (never commit this file)
JWT_SECRET=your-development-secret-key-here
JWT_ALGORITHM=HS256
DATABASE_URL=postgresql://user:pass@localhost:5432/devdb
API_KEY=dev_api_key_here
```

**.env.example File**:
```bash
# .env.example (commit this as template)
JWT_SECRET=your-jwt-secret-here
JWT_ALGORITHM=HS256
DATABASE_URL=postgresql://user:pass@host:5432/dbname
API_KEY=your-api-key-here
```

**.gitignore**:
```
.env
.env.local
.env.*.local
*.key
*.pem
secrets/
```

### Loading Environment Variables

**Python**:
```python
from dotenv import load_dotenv
import os

# Load .env file
load_dotenv()

# Access variables
JWT_SECRET = os.environ.get('JWT_SECRET')
if not JWT_SECRET:
    raise ValueError("JWT_SECRET environment variable not set")
```

**Node.js**:
```javascript
require('dotenv').config();

const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET) {
    throw new Error('JWT_SECRET environment variable not set');
}
```

### Production Deployment

**Platform-Specific**:

**Vercel**:
```bash
vercel env add JWT_SECRET production
```

**Heroku**:
```bash
heroku config:set JWT_SECRET=your-secret-key
```

**AWS**:
- Use AWS Secrets Manager
- Or AWS Systems Manager Parameter Store

**Docker**:
```bash
docker run -e JWT_SECRET=your-secret-key myapp
```

**Kubernetes**:
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
type: Opaque
data:
  jwt-secret: base64-encoded-secret
```

## Secret Generation

### Strong Random Secrets

**Requirements**:
- Cryptographically random
- Sufficient length (256+ bits)
- Unpredictable
- Unique per environment

**Generation Methods**:

**Command Line**:
```bash
# Generate 256-bit secret (32 bytes)
openssl rand -base64 32

# Generate 512-bit secret (64 bytes)
openssl rand -base64 64

# Generate hex secret
openssl rand -hex 32
```

**Python**:
```python
import secrets

# Generate URL-safe secret
secret = secrets.token_urlsafe(32)

# Generate hex secret
secret = secrets.token_hex(32)
```

**Node.js**:
```javascript
const crypto = require('crypto');

// Generate random secret
const secret = crypto.randomBytes(32).toString('base64');
```

### Secret Strength

**Weak Secrets** (Never Use):
- "secret"
- "password123"
- "myapp-secret"
- Short strings (< 16 characters)
- Dictionary words

**Strong Secrets**:
- 32+ random bytes
- Base64 or hex encoded
- Generated by crypto library
- Unique per environment

## Secret Storage

### Development Environment

**Local .env File**:
- Store in project root
- Load with dotenv library
- Never commit to git
- Document in .env.example

**Team Sharing**:
- Use secure password manager (1Password, LastPass)
- Share via encrypted channels
- Document access procedures
- Rotate when team members leave

### Production Environment

**Cloud Secret Managers**:

**AWS Secrets Manager**:
```python
import boto3

client = boto3.client('secretsmanager')
response = client.get_secret_value(SecretId='prod/jwt-secret')
JWT_SECRET = response['SecretString']
```

**Google Cloud Secret Manager**:
```python
from google.cloud import secretmanager

client = secretmanager.SecretManagerServiceClient()
name = "projects/PROJECT_ID/secrets/jwt-secret/versions/latest"
response = client.access_secret_version(request={"name": name})
JWT_SECRET = response.payload.data.decode('UTF-8')
```

**Azure Key Vault**:
```python
from azure.keyvault.secrets import SecretClient
from azure.identity import DefaultAzureCredential

credential = DefaultAzureCredential()
client = SecretClient(vault_url="https://myvault.vault.azure.net/", credential=credential)
JWT_SECRET = client.get_secret("jwt-secret").value
```

**HashiCorp Vault**:
```python
import hvac

client = hvac.Client(url='https://vault.example.com')
secret = client.secrets.kv.v2.read_secret_version(path='jwt-secret')
JWT_SECRET = secret['data']['data']['value']
```

## Secret Rotation

### Why Rotate Secrets?

**Security Reasons**:
- Limit exposure window
- Mitigate compromised secrets
- Comply with security policies
- Reduce risk over time

**When to Rotate**:
- Regularly (quarterly, annually)
- After security incident
- When employee leaves
- After suspected compromise
- During security audits

### Rotation Strategy

**Zero-Downtime Rotation**:

**Step 1: Add New Secret**:
```
OLD_JWT_SECRET=old-secret-key
NEW_JWT_SECRET=new-secret-key
```

**Step 2: Accept Both Secrets**:
```python
def verify_token(token):
    try:
        # Try new secret first
        return jwt.decode(token, NEW_JWT_SECRET)
    except:
        # Fall back to old secret
        return jwt.decode(token, OLD_JWT_SECRET)
```

**Step 3: Issue Tokens with New Secret**:
```python
def generate_token(user_id):
    return jwt.encode({'sub': user_id}, NEW_JWT_SECRET)
```

**Step 4: Remove Old Secret**:
- Wait for all old tokens to expire
- Remove OLD_JWT_SECRET
- Use only NEW_JWT_SECRET

## Access Control

### Who Needs Access?

**Development**:
- Developers: Development secrets
- CI/CD: Test secrets
- Staging: Staging secrets

**Production**:
- Minimal team members
- Automated systems only
- Audit all access
- Time-limited access

### Access Patterns

**Developers**:
- Local .env files
- Shared via secure channels
- No production access

**CI/CD Pipelines**:
- Environment variables in CI
- Secrets management integration
- Scoped to specific jobs

**Production Systems**:
- Cloud secret managers
- Service accounts
- No human access to secrets

## Audit and Monitoring

### What to Log

**Secret Access**:
- When secrets are accessed
- Which service accessed them
- Success or failure
- IP address or service identity

**Secret Changes**:
- When secrets are created
- When secrets are updated
- When secrets are deleted
- Who made the change

### Monitoring

**Alerts**:
- Unusual access patterns
- Failed access attempts
- Secret rotation due
- Secrets approaching expiration

**Regular Reviews**:
- Audit secret usage
- Review access permissions
- Check for unused secrets
- Verify rotation schedule

## Common Mistakes

### 1. Committing Secrets to Git

**Problem**: Secrets in version control history forever

**Prevention**:
- Use .gitignore
- Pre-commit hooks
- Secret scanning tools
- Code review

**If It Happens**:
- Rotate compromised secrets immediately
- Remove from git history (git filter-branch)
- Notify security team

### 2. Logging Secrets

**Problem**: Secrets in log files

**Bad**:
```python
logger.info(f"Using JWT secret: {JWT_SECRET}")
logger.debug(f"Database URL: {DATABASE_URL}")
```

**Good**:
```python
logger.info("JWT authentication configured")
logger.debug("Database connection established")
```

### 3. Exposing Secrets in Error Messages

**Problem**: Secrets in error responses

**Bad**:
```python
raise Exception(f"Failed to connect to {DATABASE_URL}")
```

**Good**:
```python
raise Exception("Failed to connect to database")
# Log full details server-side only
```

### 4. Sharing Secrets Insecurely

**Problem**: Secrets sent via email, Slack, etc.

**Solution**:
- Use secure password managers
- Encrypted communication channels
- Time-limited sharing links
- In-person transfer for critical secrets

### 5. Same Secrets Across Environments

**Problem**: Development and production use same secrets

**Solution**:
- Unique secrets per environment
- Different strength requirements
- Separate access controls

## Best Practices

### 1. Never Commit Secrets
- Use .gitignore
- Use .env files
- Use secret managers

### 2. Generate Strong Secrets
- Cryptographically random
- Sufficient length (256+ bits)
- Unique per environment

### 3. Use Environment Variables
- Load from .env in development
- Platform-specific in production
- Validate on startup

### 4. Rotate Regularly
- Quarterly or annually
- After security events
- Zero-downtime rotation

### 5. Limit Access
- Principle of least privilege
- Audit access logs
- Time-limited access

### 6. Monitor Usage
- Log access attempts
- Alert on anomalies
- Regular audits

### 7. Document Procedures
- Secret generation process
- Rotation procedures
- Access request process
- Incident response

### 8. Use Secret Managers
- Cloud-native solutions
- Encrypted storage
- Access controls
- Audit logging

### 9. Validate on Startup
- Check required secrets exist
- Fail fast if missing
- Clear error messages

### 10. Plan for Compromise
- Rotation procedures
- Incident response
- Communication plan

## Validation Checklist

- [ ] No secrets in source code
- [ ] .env file in .gitignore
- [ ] .env.example provided
- [ ] Strong secret generation
- [ ] Different secrets per environment
- [ ] Secrets loaded from environment
- [ ] Validation on application startup
- [ ] Access controls in place
- [ ] Rotation schedule defined
- [ ] Audit logging enabled
- [ ] Documentation complete
- [ ] Team trained on procedures

## Success Criteria

Secure secret management ensures:
- No secrets in version control
- Strong, unique secrets
- Proper access controls
- Regular rotation
- Comprehensive audit trail
- Quick incident response

---

**Application**: Use this skill when setting up new projects, configuring deployments, or reviewing security practices for secret management.
