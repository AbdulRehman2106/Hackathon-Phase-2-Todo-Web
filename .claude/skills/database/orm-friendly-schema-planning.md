# Skill: ORM-Friendly Schema Planning (SQLModel Compatible)

## Purpose
Design database schemas that work seamlessly with SQLModel ORM, following conventions that enable clean model definitions and efficient database operations.

## When to Use
- Designing schemas for SQLModel/SQLAlchemy applications
- Planning Python backend data models
- Ensuring ORM compatibility in schema design
- Reviewing schemas for ORM best practices

## Instruction

### SQLModel Compatibility Requirements

SQLModel schemas should follow these conventions:

1. **UUID Primary Keys**: Use UUID for primary keys
2. **Consistent Naming**: snake_case for all identifiers
3. **Explicit Relationships**: Clear foreign key definitions
4. **Type Mapping**: Use types with clear Python equivalents
5. **Default Values**: Handle defaults appropriately

### Type Mapping Reference

```yaml
postgresql_to_python:
  UUID: uuid.UUID
  VARCHAR(n): str
  TEXT: str
  INTEGER: int
  BIGINT: int
  BOOLEAN: bool
  DECIMAL: Decimal
  FLOAT: float
  DATE: date
  TIME: time
  TIMESTAMP: datetime
  TIMESTAMPTZ: datetime  # with timezone
  JSONB: dict | list
  ARRAY: list
```

### Schema Design for SQLModel

#### Table Definition Pattern

```yaml
design_considerations:
  primary_key:
    type: UUID
    python_type: uuid.UUID
    default: Generated by database (gen_random_uuid())
    sqlmodel_field: Field(default_factory=uuid4, primary_key=True)

  timestamps:
    created_at:
      type: TIMESTAMP WITH TIME ZONE
      default: NOW()
      nullable: false
    updated_at:
      type: TIMESTAMP WITH TIME ZONE
      default: NOW()
      nullable: false
      note: Application responsible for updating

  foreign_keys:
    naming: "{table_singular}_id"
    type: UUID
    python_type: uuid.UUID
    constraint: REFERENCES {table}(id)
```

#### Example Schema with SQLModel Mapping

```yaml
table: tasks

columns:
  id:
    postgres: UUID PRIMARY KEY DEFAULT gen_random_uuid()
    sqlmodel: Field(default_factory=uuid4, primary_key=True)
    python_type: uuid.UUID

  user_id:
    postgres: UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE
    sqlmodel: Field(foreign_key="users.id")
    python_type: uuid.UUID

  title:
    postgres: VARCHAR(255) NOT NULL
    sqlmodel: Field(max_length=255)
    python_type: str

  description:
    postgres: TEXT
    sqlmodel: Field(default=None)
    python_type: str | None

  status:
    postgres: VARCHAR(50) NOT NULL DEFAULT 'pending'
    sqlmodel: Field(default="pending", max_length=50)
    python_type: str

  priority:
    postgres: VARCHAR(20) DEFAULT 'medium'
    sqlmodel: Field(default="medium", max_length=20)
    python_type: str | None

  due_date:
    postgres: DATE
    sqlmodel: Field(default=None)
    python_type: date | None

  is_completed:
    postgres: BOOLEAN NOT NULL DEFAULT FALSE
    sqlmodel: Field(default=False)
    python_type: bool

  created_at:
    postgres: TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
    sqlmodel: Field(default_factory=datetime.utcnow)
    python_type: datetime

  updated_at:
    postgres: TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
    sqlmodel: Field(default_factory=datetime.utcnow)
    python_type: datetime
```

### Relationship Design

#### One-to-Many Relationship

```yaml
relationship: User has many Tasks

parent_table: users
child_table: tasks

schema_design:
  tasks:
    user_id: UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE

sqlmodel_mapping:
  User_model:
    tasks: Relationship(back_populates="user")

  Task_model:
    user_id: Field(foreign_key="users.id")
    user: Relationship(back_populates="tasks")
```

#### Many-to-Many Relationship

```yaml
relationship: Tasks have many Tags, Tags have many Tasks

tables:
  - tasks
  - tags
  - task_tags (junction)

schema_design:
  task_tags:
    task_id: UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE
    tag_id: UUID NOT NULL REFERENCES tags(id) ON DELETE CASCADE
    PRIMARY KEY: (task_id, tag_id)

sqlmodel_mapping:
  junction_table: Separate SQLModel class (TaskTag)

  Task_model:
    tags: Relationship(back_populates="tasks", link_model=TaskTag)

  Tag_model:
    tasks: Relationship(back_populates="tags", link_model=TaskTag)
```

### Nullable Fields and Defaults

```yaml
nullable_patterns:

  required_field:
    postgres: VARCHAR(255) NOT NULL
    sqlmodel: Field(...)  # no default, not Optional
    python_type: str

  optional_field:
    postgres: VARCHAR(255)  # nullable by default
    sqlmodel: Field(default=None)
    python_type: str | None

  default_value:
    postgres: VARCHAR(50) NOT NULL DEFAULT 'pending'
    sqlmodel: Field(default="pending")
    python_type: str

  computed_default:
    postgres: TIMESTAMP DEFAULT NOW()
    sqlmodel: Field(default_factory=datetime.utcnow)
    python_type: datetime
```

### Enum Handling

```yaml
approach_1_check_constraint:
  postgres: |
    status VARCHAR(50) NOT NULL,
    CONSTRAINT ck_tasks_status CHECK (status IN ('pending', 'in_progress', 'completed'))
  sqlmodel: Field(default="pending")  # validation in Pydantic model

approach_2_python_enum:
  python_enum: |
    class TaskStatus(str, Enum):
        PENDING = "pending"
        IN_PROGRESS = "in_progress"
        COMPLETED = "completed"
  sqlmodel: Field(default=TaskStatus.PENDING)
  postgres: VARCHAR(50) with check constraint

recommendation: |
  Use Python enum for type safety in code.
  Add database check constraint for data integrity.
```

### Index Considerations for ORM

```yaml
indexes_to_define:
  foreign_keys:
    purpose: Fast relationship loading
    example: CREATE INDEX ix_tasks_user_id ON tasks(user_id);

  query_patterns:
    purpose: Support common ORM queries
    analysis: Review typical .filter() and .order_by() calls

sqlmodel_query_patterns:
  filter_by_user:
    query: session.exec(select(Task).where(Task.user_id == user_id))
    index: ix_tasks_user_id

  filter_by_status:
    query: session.exec(select(Task).where(Task.status == "pending"))
    index: ix_tasks_status

  order_by_created:
    query: session.exec(select(Task).order_by(Task.created_at.desc()))
    index: ix_tasks_created_at
```

### Migration Compatibility

```yaml
migration_considerations:
  naming_consistency:
    - Table names in migrations match SQLModel __tablename__
    - Column names exactly match model field names

  constraint_naming:
    - Use consistent naming convention
    - SQLModel can auto-generate but explicit is better

  default_handling:
    - Defaults can be set in database, model, or both
    - Prefer database defaults for consistency
    - Use server_default for database-level defaults

  nullable_changes:
    - Plan for nullable â†’ NOT NULL migrations
    - Requires default value or data migration
```

### Schema Documentation Template

```markdown
## Table: tasks (ORM: Task)

### SQLModel Mapping
- **Model Class**: `Task`
- **Table Name**: `tasks`
- **Primary Key**: `id` (UUID)

### Columns

| Column | Postgres Type | Python Type | SQLModel Field | Notes |
|--------|---------------|-------------|----------------|-------|
| id | UUID PK | uuid.UUID | Field(primary_key=True) | Generated |
| user_id | UUID FK | uuid.UUID | Field(foreign_key="users.id") | Required |
| title | VARCHAR(255) | str | Field(max_length=255) | Required |
| status | VARCHAR(50) | str | Field(default="pending") | Enum values |
| created_at | TIMESTAMPTZ | datetime | Field(default_factory=...) | Auto-set |

### Relationships
- **user**: Relationship to User model (many-to-one)
- **tags**: Relationship to Tag model (many-to-many via TaskTag)

### Indexes Required
- `ix_tasks_user_id` on `user_id`
- `ix_tasks_status` on `status`
```

### ORM Compatibility Checklist

- [ ] UUID primary keys (compatible with SQLModel default)
- [ ] snake_case naming throughout
- [ ] Foreign keys properly defined
- [ ] Nullable columns mapped to Optional types
- [ ] Default values aligned between DB and model
- [ ] Relationships documented
- [ ] Indexes created for foreign keys
- [ ] Enum values consistent between DB constraints and Python

## Output Format
ORM-compatible schema documentation suitable for database design and SQLModel implementation planning.

## Related Skills
- relational-schema-design
- model-user-owned-resources
- design-indexes-performance
